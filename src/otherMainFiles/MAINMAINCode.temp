#include <Arduino.h>
#include <Servo.h>
#include "Data.h"
#include "Nav.h"
#include "Battery.h"
#include "Chrono.h"
#include "Data.h"
#include "Buzzer.h"
#include "PID.h"
#include "./SdCard/SD.h"
#include "BTLE.h"
#include "Parachute.h"
#include "ServoControl.h"
#include "Telemetry.h"
#include "Pyro.h"
#include "Config.h"
#include "Kalman.h"
#include "./eui/EUIMyLib.h"



Chrono writeTimer;
Chrono servoTimer;
Chrono pidTimer;
Chrono printTimer;
Chrono batteryCheckTimer;
Chrono landingDetectTimer;

float accelMag = 0;
bool flashWriteStatus = false;
bool PIDStatus = false;
bool gyroZeroStatus = false;
unsigned long landingTimer = 0;
bool landingWait = false;
unsigned long poweredFlightSafetyTime = 0;


unsigned long timer = 0;

void checkAngleThreshold()
{
  if (abs(data.yaw) >= ABORT_ANGLE_THRESHOLD || abs(data.pitch) >= ABORT_ANGLE_THRESHOLD)
  {
    Serial.println("Angle Past Limit");
    data.state = PARACHUTE_DESCENT;
  }
}

void handleServoCentering()
{
  if (nonLoggedData.servoCentersAvailable == true)
  {
    nonLoggedData.servoCentersAvailable = false;
    Serial.print("Writing To servos");
    Serial.print("   Y: ");
    Serial.print(data.Y_Servo_Center);
    Serial.print("   Z: ");
    Serial.println(data.Z_Servo_Center);
    // Write new center values to servos
  }
}

bool writingMode = false;
bool finishedWriting = false;
unsigned long prevLoopTime;
unsigned long currentLoopTime;

void setup()
{
  delay(4000);
  data.state = INITIALIZING;
  Serial.begin(115200);
  //checkBatteryVoltage();

  //initPyro();
  // Attach servos and center them
  buzzStartup();

  initFlash();
  initBluetooth();
  initBuzzer();
  initPIDs();
  initServos();
  initParachute();

  delay(2000);

  // Initialize all sensors and stuff.
  // Put state into error if not all good.

  initNav();

  buzzStartup();
  delay(500);
  buzzStartup();
  delay(500);
  buzzStartup();

  delay(2000);

  buzzStartup();
  delay(200);
  buzzStartup();

  
  writingMode = true;
  //initEUI();

  // Put state into IDLE when finished if all good.
  Serial.println("Setup Success. Entering Loop");
  prevLoopTime = micros();
  currentLoopTime = micros();
  data.state = IDLE;

 
}

void handleDoNav()
{

  handleAltimeter();

  if (pidTimer.hasPassed(NAV_RATE))
  {

    getAccel();
    getYPR();
    updateAccel(data.worldAx);

    if(PIDStatus == true){
    setZPIDInput(data.pitch);
    setYPIDInput(data.yaw);
    computeBothPIDs();
    moveZServo(int(round(data.Z_Servo_Center + data.servo_z)));
    moveYServo(int(round(data.Y_Servo_Center + data.servo_y)));
    }

    pidTimer.restart();
  };

  if (isNewAltimeterData())
  {
    updateBaro(getAltitude());
  }
}

void handleWritingToFlash()
{
  if (writingMode == true)
  {
    if (!handleWriteFlash())
    {
      writingMode = false;
      finishedWriting = true;
    }
  }
}

void loop()
{
  currentLoopTime = micros();
  data.loopTime = float(currentLoopTime - prevLoopTime) / 1000000.0f;
  prevLoopTime = currentLoopTime;


  checkBTLE();
  
  handleDoNav();

  handleWritingToFlash();

  

  switch (data.state)
  {

  case IDLE:
    // Wait for BTLE Launch command
    // Send periodic data to BTLE
    
    handleSendTelemetry();

    // wait for zero gyros command
    if (nonLoggedData.zeroGyrosStatus == true)
    {
      nonLoggedData.zeroGyrosStatus = false;
      zeroGyroscope();
    }

    // listen to BTLE for TVC centering commands if needed. Update accordingly
    handleServoCentering();
    // if rocket goes to > angleThresh => abort
    checkAngleThreshold();

    break;

  case LAUNCH_COMMANDED:
    flashWriteStatus = true;
    // Zero Gyros and other sensors as needed
    if (gyroZeroStatus == false)
    {
      gyroZeroStatus = true;
      zeroGyroscope();
    }


    handleFirePyro();

    PIDStatus = true;
    

    if (data.worldAx > LAUNCH_ACCEL_THRESHOLD)
    {
      // stop pyro charge
      poweredFlightSafetyTime = millis();
      analogWrite(PYRO2_PIN, 0);
      data.state = POWERED_ASCENT;
    }

     if (millis() - poweredFlightSafetyTime >= PARACHUTE_EJECT_SAFETY_TIME)
    {
      data.state = PARACHUTE_DESCENT;
    }

    checkAngleThreshold();

    break;
  case POWERED_ASCENT:
   
    checkAngleThreshold();

    // Check if accel magnitude is less than thresh
    accelMag = sqrt(sq(data.ax) + sq(data.ay) + sq(data.az));
    if (accelMag < ACCEL_UNPOWERED_THRESHOLD)
    {
      data.state = UNPOWERED_ASCENT;
    }

    if (millis() - poweredFlightSafetyTime >= PARACHUTE_EJECT_SAFETY_TIME)
    {
      data.state = PARACHUTE_DESCENT;
    }

    break;
  case UNPOWERED_ASCENT:
    // Center and turn off TVC
    PIDStatus = false;
    moveZServo(data.Z_Servo_Center);
    moveYServo(data.Y_Servo_Center);

    if(data.kal_V <= -1.0f){
      data.state = FREE_DESCENT;
    }

    if (millis() - poweredFlightSafetyTime >= PARACHUTE_EJECT_SAFETY_TIME)
    {
      data.state = PARACHUTE_DESCENT;
    }


    break;
  case FREE_DESCENT:
    // Detect barometer min altitude for parachute
    if (data.altitude < PARACHUTE_ALTITUDE_THRESHOLD)
    {
      // Write prachute launch to servo
      data.state = PARACHUTE_DESCENT;
    }

    if (millis() - poweredFlightSafetyTime >= PARACHUTE_EJECT_SAFETY_TIME)
    {
      data.state = PARACHUTE_DESCENT;
      landingDetectTimer.restart();
    }

    

    break;

  case PARACHUTE_DESCENT:
    // wait for accel, magnitude threshold for gravity or something
    // to detect landing
    deployParachute();
    

    if(landingDetectTimer.hasPassed(LANDING_DETECT_DELAY)){
      data.state = LANDED;
    }

    break;
  case LANDED:
    delay(2000);
    // Dump all data to SD
    flashWriteStatus = false;
    Serial.println("Writing to SD");
    transferToSD();
    buzzComplete();
    Serial.println("SD writing complete");
    while (1)
    {
      delay(500);
      buzzComplete();
    };

    while (1)
      ;

    break;

  case ERROR:
    // Send error message to BTLE
    flashWriteStatus = false;
    while (1)
      ;
    break;

  default:
    break;
  }

}